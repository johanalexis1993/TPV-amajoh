├───TPV/
├───public/
│ ├───assets/
│ │ ├───alerjenos/
│ │ └───Orders.pm3
│ ├───CSS/
│ │ ├───buttons.css
│ │ ├───forms.css
│ │ ├───general.css
│ │ ├───header-footer.css
│ │ ├───headings.css
│ │ ├───images.css
│ │ ├───layout.css
│ │ ├───scrollbar.css
│ │ ├───sidebar.css
│ │ ├───tables.css
│ │ └───var.css
│ ├───JavaScript/
│ │ ├───POSoperation/
│ │ │ ├───initApp.js
│ │ │ ├───sidebar.js
│ │ │ └───showSection.js
│ │ │
│ │ ├───api/
│ │ │ ├───requestHandler.js
│ │ │ ├───gets.js
│ │ │ ├───post.js
│ │ │ ├───put.js
│ │ │ └───delete.js
│ │ │
│ │ ├───events/
│ │ │ ├───getHandlers.js
│ │ │ ├───postHandlers.js
│ │ │ ├───putHandlers.js
│ │ │ └───deleteAndPutHandlers.js
│ │ ├───logic/
│ │ │ ├───delete/
│ │ │ │ └───updateUIAfterDelete.js
│ │ │ ├───get/
│ │ │ │ ├───autocomplete.js
│ │ │ │ ├───orderPainting.js
│ │ │ │ ├───updateTables.js
│ │ │ │ ├───createPlateElement.js
│ │ │ │ ├───paintingPlates.js
│ │ │ │ ├───renderList.js
│ │ │ │ └───processPlatesData.js
│ │ │ ├───post/
│ │ │ │ ├───createOrderLocal.js
│ │ │ │ ├───updateUIAfterPost.js
│ │ │ │ └───renderOrder.js
│ │ │ └───put/
│ │ │ ├───paintOrderItem.js
│ │ │ ├───updateUIAfterPut.js
│ │ │ ├───createOrderElements.js
│ │ │ ├───appendOrderElementsToDom.js
│ │ │ └───createAndConfigureButtons.js
│ │ └───helpers/
│ │ ├───checkAndPlaySound.js
│ │ ├───togglePlateButtons.js
│ │ ├───confirmPasword.js
│ │ ├───functionCheckbox.js
│ │ ├───generatePDF.js
│ │ ├───handleInputEvent.js
│ │ ├───renderChart.js
│ │ ├───delegarEvents.js
│ │ ├───checkAuth.js
│ │ ├───watermark.js
│ │ └───addIngredient.js
│ │───index.html
│ ├───register.html
│ ├───TPV.html
│ └──────robots.txt
│──────package.json
│────────package-lock.json
│──────.env
└──────.vite.config.js
Esa reflexión me llevó a revisar cada detalle: la espera en el render de tablas era por una petición GET con datos reales. Para optimizarlo, implementé paginación y construí el skeleton de la tabla mientras llegaban los datos (sin cache), logrando carga instantánea y 100% en accesibilidad, SEO y mejores prácticas (performance 98%).

Además, las validaciones no solo están en el backend, sino también en HTML y JavaScript. 

Reflexión: entender los fundamentos me permitió aplicar soluciones efectivas, incluso sin frameworks como React, aunque me inspiré en sus soluciones (esa experiencia gratuita vale oro). Me interesa saber: ¿cómo equilibran ustedes performance, validaciones y experiencia de usuario en proyectos reales?
